# Создание веб-сервера в Node.js с помощью модуля HTTP

Published on May 7, 2020

*   [JavaScript](https://www.digitalocean.com/community/tags/javascript "JavaScript")
*   [Node.js](https://www.digitalocean.com/community/tags/node-js "Node.js")
*   [Development](https://www.digitalocean.com/community/tags/development "Development")
*   [Programming Project](https://www.digitalocean.com/community/tags/project "Programming Project")

![Default avatar](https://images.prismic.io/digitalocean/46f22fba-7718-478b-86ae-e8b875f0473e_default-avatar.png?auto=compress,format)

By [Stack Abuse](https://www.digitalocean.com/community/users/stackabuse)

Developer and author at DigitalOcean.

Русский

![Создание веб-сервера в Node.js с помощью модуля HTTP](https://www.digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg "Создание веб-сервера в Node.js с помощью модуля HTTP")

*Автор выбрал [COVID-19 Relief Fund](https://www.brightfunds.org/funds/write-for-donations-covid-19-relief-fund) для получения пожертвования в рамках программы [Write for DOnations](https://do.co/w4do-cta).*

### Введение

При просмотре веб-страницы в браузере мы отправляем запрос на другой компьютер в Интернете, который отправляет в ответ веб-страницу. Компьютер, с которым вы взаимодействуете через Интернет, называется *веб-сервером*. Веб-сервер получает запросы HTTP от клиентов, в том числе от вашего браузера, и отправляет им ответы HTTP, например страницы HTML или код [JSON](https://www.digitalocean.com/community/tutorials/how-to-work-with-json-in-javascript) из API.

Для вывода веб-страницы сервер использует разнообразное программное обеспечение. Программное обеспечение может быть клиентским или серверным. *Клиентское программное обеспечение* отвечает за вывод контента, например за цвета панели навигации и стили текста. *Серверное программное обеспечение* отвечает за обмен, обработку и хранение данных. За обработку сетевых запросов вашего браузера и взаимодействие с базами данных в основном отвечает серверный код.

[Node.js](https://nodejs.org/en/about/) позволяет разработчикам использовать [JavaScript](https://www.digitalocean.com/community/tutorial_series/how-to-code-in-javascript) для создания серверного кода, хотя традиционно этот язык использовался в браузере для создания клиентского кода. Объединение клиентского и серверного кода в одной среде разработки упрощает создание веб-серверов, и именно поэтому Node.js стал популярным инструментом для написания серверного кода.

В этом обучающем руководстве мы научимся создавать веб-серверы с помощью [модуля `http`](https://nodejs.org/api/http.html), входящего в состав Node.js. Мы создадим веб-серверы, которые смогут возвращать данные JSON, файлы CSV и веб-страницы HTML.

## Предварительные требования

*   Убедитесь, что на используемом для разработки компьютере установлен Node.js. Для целей этого обучающего руководства мы используем версию Node.js 10.19.0. Чтобы установить его в macOS или Ubuntu 18.04, следуйте указаниям руководства **Установка Node.js и создание локальной среды разработки в macOS** или раздела [Установка с помощью PPA](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-on-ubuntu-18-04) руководства [Установка Node.js в Ubuntu 18.04](https://www.digitalocean.com/community/tutorials/how-to-install-node-js-and-create-a-local-development-environment-on-macos).
*   Платформа Node.js позволяет создавать готовые веб-серверы. Для начала вам следует познакомиться с основами Node.js. Для этого вы можете воспользоваться нашим руководством [Написание и запуск первой программы на Node.js](https://www.digitalocean.com/community/tutorials/how-to-write-and-run-your-first-program-in-node-js).
*   Также мы посвятим один из разделов этого обучающего руководства асинхронному программированию. Если вы незнакомы с асинхронным программированием в Node.js или с модулем `fs` для взаимодействия с файлами, вы можете узнать о них больше из нашей статьи [Написание асинхронного кода в Node.js](https://www.digitalocean.com/community/tutorials/how-to-write-asynchronous-code-in-node-js).

## Шаг 1 — Создание базового сервера HTTP

Для начала мы создадим сервер, возвращающий пользователю обычный текст. При этом мы рассмотрим главные концепции создания сервера, что даст нам необходимую основу для возврата более сложных форматов данных, таких как JSON.

Прежде всего нам нужно настроить доступную среду программирования для выполнения наших упражнений, а также других заданий в настоящей статье. Создайте в терминале папку с именем `first-servers`:

```
mkdir first-servers

```

Copy

Затем откройте эту папку:

```
cd first-servers

```

Copy

Затем создайте файл для кода:

```
touch hello.js

```

Copy

Откройте файл в текстовом редакторе. Мы используем редактор `nano`, потому что он доступен в терминале:

```
nano hello.js

```

Copy

Для начала мы загрузим модуль `http`, входящий в стандартную комплектацию установки Node.js. Добавьте следующую строку в `hello.js`:

first-servers/hello.js

```
const http = require("http");

```

Copy

Модуль `http` содержит функцию создания сервера, которую мы более детально рассмотрим позднее. Если вы хотите узнать больше о модулях в Node.js, познакомьтесь с нашей статьей [Создание модуля Node.js](https://www.digitalocean.com/community/tutorials/how-to-create-a-node-js-module).

На следующем шаге мы определим две константы, хост и порт, к которым будет привязан наш сервер:

first-servers/hello.js

```
...
const host = 'localhost';
const port = 8000;

```

Copy

Как указывалось ранее, веб-серверы принимают запросы из браузеров и других клиентов. Для взаимодействия с веб-сервером обычно вводится доменное имя, которое сервер DNS преобразует в IP-адрес. IP-адрес — это уникальная числовая последовательность, идентифицирующая компьютер в Интернете. Дополнительную информацию о концепции доменных имен можно узнать из нашей статьи [Введение в терминологию, компоненты и концепции DNS](https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts#domain-terminology).

Значение `localhost` — это специальный частный адрес, с помощью которого компьютеры ссылаются на себя. Обычно оно эквивалентно внутреннему IP-адресу `127.0.0.1` и доступно только локальному компьютеру, но недоступно Интернету или локальным сетям, к которым подключен компьютер.

Порт — это числовое значение, которое серверы используют как точку доступа или «дверь» к нашему IP-адресу. В нашем примере мы будем использовать для нашего веб-сервера порт `8000`. Порты `8080` и `8000` обычно используются при разработке как порты по умолчанию, и в большинстве случаев разработчики предпочитают использовать именно эти порты для серверов HTTP.

Когда мы привяжем наш сервер к этому хосту и порту, мы сможем подключаться к нашему серверу, открывая адрес `http://localhost:8000` в локальном браузере.

Добавим специальную функцию, которую в Node.js мы называем *прослушиватель запросов*. Эта функция предназначена для обработки входящих запросов HTTP и возврата ответа HTTP. Данная функция должна иметь два аргумента, объект запроса и объект ответа. Объект запроса записывает все данные поступающего запроса HTTP. Объект ответа используется для возвращения серверу ответов HTTP.

Нам нужно, чтобы наш первый сервер возвращал следующее сообщение при попытке доступа к нему: `"My first server!"`.

Добавим эту функцию:

first-servers/hello.js

```
...

const requestListener = function (req, res) {
    res.writeHead(200);
    res.end("My first server!");
};

```

Copy

Названия функций обычно описывают их назначение. Например, если мы создаем функцию прослушивателя запросов для вывода списка книг, мы назовем ее `listBooks()`. Поскольку мы рассматриваем общий пример, мы используем для него общее имя `requestListener`.

Все функции прослушивания запросов в Node.js принимают два аргумента, `req` и `res` (мы можем присвоить им другие имена, если захотим). Отправляемый пользователем запрос HTTP записывается в объекте Request, который соответствует первому аргументу, `req`. Отправляемый пользователю ответ HTTP формируется посредством взаимодействия с объектом Response во втором аргументе, `res`.

Первая строка `res.writeHead(200);` задает код состояния HTTP для ответа. Коды состояния HTTP показывают, насколько хорошо запрос HTTP обработан сервером. В данном случае код состояния `200` соответствует результату `"OK"`. Если вы хотите узнать больше о различных кодах HTTP, которые могут возвращать ваши веб-серверы, и о значении этих кодов, начните с нашего руководства [Диагностика распространенных кодов ошибок HTTP](https://www.digitalocean.com/community/tutorials/how-to-troubleshoot-common-http-error-codes).

Следующая строка функции, `res.end("My first server!") ;`, записывает ответ HTTP на клиент, который его запросил. Эта функция возвращает любые данные, которые должен возвращать сервер. В этом случае будут возвращаться текстовые данные.

Теперь мы можем создать сервер и использовать прослушиватель запросов:

first-servers/hello.js

```
...

const server = http.createServer(requestListener);
server.listen(port, host, () => {
    console.log(`Server is running on http://${host}:${port}`);
});

```

Copy

Сохраните код и закройте `nano`, нажав `CTRL+X`.

В первой строке мы создали новый объект `server` с помощью функции `createServer()` модуля `http`. Этот сервер принимает запросы HTTP и передает их нашей функции `requestListener()`.

После создания сервера мы должны привязать его к сетевому адресу. Для этого мы используем метод `server.listen()`. Он принимает три аргумента: `port`, `host` и [функцию обратного вызова](https://www.digitalocean.com/community/tutorials/how-to-write-asynchronous-code-in-node-js#asynchronous-programming-with-callbacks), срабатывающую, когда сервер начинает прослушивание.

Все эти аргументы необязательные, но всегда лучше прямо указать, какие порт и хост должен использовать веб-сервер. При развертывании веб-серверов в разных средах важно знать порт и хост, чтобы настроить балансировку нагрузки или псевдоним [DNS](https://www.digitalocean.com/community/tutorials/an-introduction-to-dns-terminology-components-and-concepts).

Функция обратного вызова регистрирует в нашей консоли сообщение о том, когда сервер начал прослушивать соединения.

**Примечание.** Хотя `requestListener()` не использует объект `req`, он должен быть первым аргументом функции.

Мы создали веб-сервер, написав менее пятнадцати строк кода. Проверим его работу, запустив программу:

```
node hello.js

```

Copy

Мы увидим в консоли следующее:

```
OutputServer is running on http://localhost:8000

```

Обратите внимание, что командная строка исчезает. Это связано с тем, что сервер Node.js — это постоянно работающий процесс. Он закрывается только при обнаружении ошибки, вызывающей сбой и завершение работы, или когда мы останавливаем процесс Node.js, запускающий сервер.

Мы используем отдельное окно терминала для взаимодействия с сервером с помощью [cURL](https://github.com/curl/curl), инструмента командной строки для обмена данными с сетью. Введите команду для отправки запроса HTTP `GET` на запущенный нами сервер:

```
curl http://localhost:8000

```

Copy

При нажатии клавиши `ENTER` на терминале появится следующее:

```
OutputMy first server!

```

Мы настроили сервер и получили от него первый ответ.

Теперь давайте подробнее разберемся с тем, что произошло во время тестирования сервера. Мы использовали cURL для отправки запроса `GET` на сервер с адресом `http://localhost:8000`. Наш сервер Node.js прослушивал соединения этого адреса. Сервер передал запрос функции `requestListener()`. Функция вернула текстовые данные с кодом состояния `200`. Сервер отправил ответ в cURL, и на нашем терминале появилось сообщение.

Прежде чем продолжить, нажмем `CTRL+C` и закроем запущенный сервер. Это прервет работу сервера и вернет нас в командную строку.

Большинство сайтов и API не используют для ответов формат обычного текста. Страницы HTML и данные JSON —наиболее распространенные форматы ответов. На следующем шаге мы узнаем, как возвращать ответы HTTP в распространенных форматах данных, которые мы встречаем в Интернете.

## Шаг 2 — Возврат разных типов контента

Возвращаемый веб-сервером ответ может иметь разные форматы. Мы уже упоминали JSON и HTML, но также существуют и другие текстовые форматы, в том числе XML и CSV. Кроме того, веб-серверы могут возвращать данные и не в текстовом формате, в том числе файлы PDF, архивы zip, аудио- и видеофайлы.

В этой статье мы расскажем о возврате следующих типов данных, помимо обычного текста:

*   JSON
*   CSV
*   HTML

Все эти три типа данных основаны на текстовом формате и очень часто используются для распространения контента в Интернете. Многие инструменты и языки разработки для серверов поддерживают возврат этих типов данных. В контексте Node.js нам необходимы две вещи:

1.  Задать для заголовка `Content-Type` в ответах HTTP подходящее значение.
2.  Убедиться, что `res.end()` получает данные в правильном формате.

Посмотрим примеры в действии. Код, который мы будем писать в этом и следующих разделах, будет очень похож на уже написанный нами код. Большинство изменений существуют в функции `requestListener()`. Давайте создадим файлы с этим кодом шаблона, чтобы упростить работу в следующих разделах.

Создайте новый файл с именем `html.js`. Этот файл будет использоваться позднее для возврата текста HTML в ответе HTTP. Здесь мы введем код шаблона и скопируем его в другие серверы, возвращающие разные типы.

Введите в терминале следующее:

```
touch html.js

```

Copy

Теперь откройте этот файл в текстовом редакторе:

```
nano html.js

```

Copy

Скопируем код шаблона. Введите в `nano` следующее:

first-servers/html.js

```
const http = require("http");

const host = 'localhost';
const port = 8000;

const requestListener = function (req, res) {};

const server = http.createServer(requestListener);
server.listen(port, host, () => {
    console.log(`Server is running on http://${host}:${port}`);
});

```

Copy

Сохраните файл `html.js` и закройте его с помощью `CTRL+X`, а затем вернитесь в терминал.

Теперь скопируем этот файл в два новых файла. Первый файл будет возвращать данные CSV в ответе HTTP:

```
cp html.js csv.js

```

Copy

Второй файл будет возвращать ответ JSON на сервере:

```
cp html.js json.js

```

Copy

Остальные файлы будут предназначены для последующих упражнений:

```
cp html.js htmlFile.js
cp html.js routes.js

```

Copy

Теперь мы готовы продолжить наши упражнения. Начнем с возврата JSON.

### Вывод JSON

*Нотация объектов JavaScript (JSON)* представляет собой текстовый формат обмена данными. Как предполагает его название, данный формат основан на объектах JavaScript, но при этом он не зависит от языка, то есть его может использовать любой язык программирования, способный парсить его синтаксис.

Формат JSON обычно используется API для приема и возврата данных. Его популярность обусловлена меньшим размером, чем у XML и других форматов обмена данными, а также наличием инструментов для парсинга его синтаксиса без излишних усилий. Если вы хотите узнать больше о JSON, вы можете прочитать наше руководство [Работа с JSON в JavaScript](https://www.digitalocean.com/community/tutorials/how-to-work-with-json-in-javascript).

Откройте файл `json.js` с помощью `nano`:

```
nano json.js

```

Copy

Нам нужно вернуть ответ JSON. Изменим функцию `requestListener()` для возврата соответствующего заголовка для всех ответов JSON посредством изменения выделенных строк:

first-servers/json.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
};
...

```

Copy

Метод `res.setHeader()` добавляет заголовок HTTP к ответу. Заголовки HTTP содержат дополнительную информацию, которая может быть прикреплена к запросу или ответу. Метод `res.setHeader()` принимает два аргумента: название заголовка и его значение.

Заголовок `Content-Type` используется для указания формата данных, который также называется типом носителя и отправляется с запросом или ответом. В этом случае `Content-Type` имеет значение `application/json`.

Возвратим пользователю контент JSON. Изменим `json.js` следующим образом:

first-servers/json.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
    res.writeHead(200);
    res.end(`{"message": "This is a JSON response"}`);
};
...

```

Copy

Как и ранее, мы сообщаем пользователю об успешном выполнении запроса, возвращая статус `200`. Теперь наш аргумент строки в вызове `response.end()` содержит корректный код JSON.

Сохраните и закройте `json.js`, нажав `CTRL+X`. Запустим сервер с помощью команды `node`:

```
node json.js

```

Copy

Подключимся к серверу в другом терминале, используя cURL:

```
curl http://localhost:8000

```

Copy

Нажав `ENTER`, мы увидим следующий результат:

```
Output{"message": "This is a JSON response"}

```

Нам удалось успешно вывести ответ JSON, как и во многих популярных API для создания приложений. Обязательно закройте работающий сервер, нажав `CTRL+C`, чтобы вернуться в стандартную командную строку терминала. Теперь перейдем к CSV, другому популярному формату вывода данных.

### Обслуживание CSV

Формат *разделенных запятой значений* (CSV) — это стандартный текстовый формат вывода табличных данных. В большинстве случаев строки разделяются символами новой строки, а элементы внутри строки разделяются запятым.

Откройте файл `csv.js` в нашем рабочем пространстве с помощью текстового редактора:

```
nano csv.js

```

Copy

Добавим следующие строки в функцию `requestListener()`:

first-servers/csv.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", "attachment;filename=oceanpals.csv");
};
...

```

Copy

Теперь `Content-Type` имеет значение `text/csv`, соответствующее формату файлов CSV. Также мы добавим заголовок `Content-Disposition`. Этот заголовок указывает браузеру способ отображения данных, особенно в браузере или в отдельном файле.

При возврате ответов CSV большинство современных браузеров автоматически загружают файл, даже если заголовок `Content-Disposition` не установлен. Однако при возврате файла CSV этот заголовок нужно добавить, поскольку он позволяет нам задать имя файла CSV. Мы сообщаем браузеру, что файл CSV является вложением, и что его следует загрузить. Затем мы сообщаем браузеру, что файлу присвоено имя `oceanpals.csv`.

Запишем данные CSV в ответе HTTP:

first-servers/csv.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "text/csv");
    res.setHeader("Content-Disposition", "attachment;filename=oceanpals.csv");
    res.writeHead(200);
    res.end(`id,name,email\n1,Sammy Shark,shark@ocean.com`);
};
...

```

Copy

Как и раньше, мы возвращаем статус `200`/`OK` в нашем ответе. Теперь наш вызов `res.end()` содержит строку корректного файла CSV. Значения в каждом столбце разделяются запятыми, а строки разделяются символом новой строки (`\n`). У нас имеется две строки, одна для заголовка таблицы, а другая — для данных.

Протестируем этот сервер в браузере. Сохраните файл `csv.js` и закройте редактор, нажав `CTRL+X`.

Запустите сервер с помощью команды Node.js:

```
node csv.js

```

Copy

Откроем сервер в другом терминале с помощью cURL:

```
curl http://localhost:8000

```

Copy

На консоли появится следующее:

```
Outputid,name,email
1,Sammy Shark,shark@ocean.com

```

Если мы откроем в браузере адрес `http://localhost:8000`, загрузится файл CSV. Файл будет иметь имя `oceanpals.csv`.

Закройте работающий сервер, нажав `CTRL+C` для возврата в стандартную командную строку терминала.

Мы рассмотрели возврат данных в форматах JSON и CSV, которые часто используются в API. Теперь перейдем к возврату данных сайтов, просматриваемых людьми в браузере.

### Обслуживание кода HTML

[Гипертекстовый язык разметки (HTML)](https://developer.mozilla.org/en-US/docs/Web/HTML) — самый распространенный формат, используемый пользователями при взаимодействии с серверами через браузер. Он был создан для структурирования веб-контента. Браузеры разработаны для отображения контента в формате HTML, оформленного с использованием стилей [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS), еще одной клиентской веб-технологии для настройки внешнего вида сайтов.

Откроем файл `html.js` в текстовом редакторе еще раз:

```
nano html.js

```

Copy

Изменим функцию `requestListener()` так, чтобы она возвращала подходящий заголовок `Content-Type` для ответа HTML:

first-servers/html.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "text/html");
};
...

```

Copy

Возвратим пользователю контент HTML. Добавьте в файл `html.js` выделенные строки, чтобы он выглядел следующим образом:

first-servers/html.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "text/html");
    res.writeHead(200);
    res.end(`<html><body><h1>This is HTML</h1></body></html>`);
};
...

```

Copy

Вначале мы добавляем код состояния HTTP. Затем мы вызываем `response.end()` с аргументом строки, содержащим корректный код HTML. Открывая сервер в браузере, мы увидим страницу HTML с одним тегом заголовка со значением `This is HTML`.

Сохраним файл и закроем редактор, нажав `CTRL+X`. Запустим сервер с помощью команды `node`:

```
node html.js

```

Copy

После запуска программы мы увидим сообщение `Server is running on http://localhost:8000`.

Откройте в браузере адрес `http://localhost:8000`. Страница будет выглядеть следующим образом:

![Изображение ответа HTML, возвращаемого сервером Node.js](https://assets.digitalocean.com/articles/67009/html-response.png)

Закроем работающий сервер, нажав `CTRL+C` для возврата в стандартную командную строку терминала.

Код HTML часто добавляется в файл отдельно от серверного кода, такого как наши программы Node.js. Посмотрим, как можно выводить ответы HTML из файлов.

## Шаг 3 — Вывод страницы HTML из файла

Код HTML можно выводить пользователю в виде строк Node.js, но желательно загружать файлы HTML и выводить их содержимое. Так нам не нужно хранить длинные строки кода HTML в файле Node.js, за счет чего код становится более компактным, и мы получаем возможность независимо работать с разными частями сайта. Такая концепция разделения часто используется в веб-разработке, поэтому важно знать, как правильно загружать файлы HTML для их поддержки в Node.js.

Для вывода файлов HTML мы загружаем их с помощью [модуля `fs`](https://nodejs.org/api/fs.html#fs_file_system) и используем их данные при написании ответа HTTP.

Вначале создадим файл HTML, который будет возвращать наш веб-сервер. Создайте новый файл HTML:

```
touch index.html

```

Copy

Откройте файл `index.html` в текстовом редакторе:

```
nano index.html

```

Copy

Наша веб-страница будет минимальной. Она будет иметь оранжевый фон и содержать текст приветствия в центре. Добавьте в файл следующий код:

first-servers/index.html

```
<!DOCTYPE html>

<head>
    <title>My Website</title>
    <style>
        *,
        html {
            margin: 0;
            padding: 0;
            border: 0;
        }

        html {
            width: 100%;
            height: 100%;
        }

        body {
            width: 100%;
            height: 100%;
            position: relative;
            background-color: rgb(236, 152, 42);
        }

        .center {
            width: 100%;
            height: 50%;
            margin: 0;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: "Trebuchet MS", Helvetica, sans-serif;
            text-align: center;
        }

        h1 {
            font-size: 144px;
        }

        p {
            font-size: 64px;
        }
    </style>
</head>

<body>
    <div class="center">
        <h1>Hello Again!</h1>
        <p>This is served from a file</p>
    </div>
</body>

</html>

```

Copy

На этой веб-странице отображается две строки текста: `Hello Again!` и `This is served from a file`. Строки отображаются друг над другом в центре страницы. Первая строка текста отображается как заголовок, то есть она будет больше. Вторая строка текста будет немного меньше. Весь текст будет выводиться белым цветом на оранжевом фоне страницы.

Хотя это не относится к настоящей статье и серии статей, вы можете узнать больше об HTML, CSS и других технологиях создания веб-клиентов с помощью руководства [Введение в веб-технологии от Mozilla](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web).

Это весь код HTML, который нам нужен, так что теперь можно сохранить и закрыть файл, нажав `CTRL+X`. Теперь мы можем перейти к коду сервера.

В этом упражнении мы будем работать с файлом `htmlFile.js`. Откройте этот файл в текстовом редакторе:

```
nano htmlFile.js

```

Copy

Поскольку нам нужно прочитать файл, для начала импортируем модуль `fs`:

first-servers/htmlFile.js

```
const http = require("http");
const fs = require('fs').promises;
...

```

Copy

Этот модуль содержит функцию `readFile()`, которую мы будем использовать для загрузки файла HTML. Мы импортируем вариант обещания в соответствии с современными передовыми практиками работы с JavaScript. Мы используем обещания, поскольку с синтаксической точки зрения они лучше функций обратного вызова, к которым нам пришлось бы прибегнуть, если бы мы назначили `fs` как `require('fs')`. Дополнительную информацию о лучших практиках асинхронного программирования можно найти в нашем руководстве [Написание асинхронного кода в Node.js](https://www.digitalocean.com/community/tutorials/how-to-write-asynchronous-code-in-node-js).

Нам нужно, чтобы при отправке пользователем запроса к системе считывался наш файл HTML. Для начала изменим `requestListener()` для чтения файла:

first-servers/htmlFile.js

```
...
const requestListener = function (req, res) {
    fs.readFile(__dirname + "/index.html")
};
...

```

Copy

Мы используем метод `fs.readFile()` для загрузки файла. Он использует аргумент `__dirname + "/index.html"`. Специальная переменная [`__dirname`](https://nodejs.org/api/modules.html#modules_dirname) содержит абсолютный путь к директории запуска кода Node.js. В конце мы добавляем `/index.html`, чтобы мы могли загрузить ранее созданный файл HTML.

Возвратим страницу HTML после ее загрузки:

first-servers/htmlFile.js

```
...
const requestListener = function (req, res) {
    fs.readFile(__dirname + "/index.html")
        .then(contents => {
            res.setHeader("Content-Type", "text/html");
            res.writeHead(200);
            res.end(contents);
        })
};
...

```

Copy

Если обещание `fs.readFile()` успешно выполняется, оно возвращает свои данные. Для этого случая мы используем метод `then()`. Параметр `contents` содержит данные файла HTML.

Вначале мы задаем для заголовка `Content-Type` значение `text/html`, чтобы сообщить клиенту, что мы возвращаем данные HTML. Затем мы пишем код состояния, показывая, что запрос выполнен успешно. В заключение мы отправляем на клиент загруженную страницу HTML с данными в переменной `contents`.

Иногда метод `fs.readFile()` может выполняться с ошибками, и нам нужно предусмотреть подобные случаи. Добавьте в функцию `requestListener()` следующее:

first-servers/htmlFile.js

```
...
const requestListener = function (req, res) {
    fs.readFile(__dirname + "/index.html")
        .then(contents => {
            res.setHeader("Content-Type", "text/html");
            res.writeHead(200);
            res.end(contents);
        })
        .catch(err => {
            res.writeHead(500);
            res.end(err);
            return;
        });
};
...

```

Copy

Сохраните файл и закройте `nano`, нажав `CTRL+X`.

Когда в обещании возникает ошибка, оно отклоняется. Эта ситуация обрабатывается с помощью метода `catch()`. Он принимает ошибку, возвращаемую `fs.readFile()`, устанавливает код состояния `500`, сигнализирующий о внутренней ошибке, и возвращает пользователю сообщение об ошибке.

Запустите наш сервер с помощью команды `node`:

```
node htmlFile.js

```

Copy

Откройте в браузере адрес `http://localhost:8000`. Вы увидите следующую страницу:

![Изображение страницы HTML, загруженной из файла в Node.js](https://assets.digitalocean.com/articles/67009/html-file.png)

Мы вывели пользователю страницу HTML с сервера. Теперь мы можем закрыть запущенный сервер, нажав `CTRL+C`. Сделав это, мы увидим командную строку терминала.

При написании такого кода в производственной среде не всегда желательно загружать страницу HTML при каждом получении запроса HTTP. В нашем случае страница HTML занимает всего 800 байт, но на сложных сайтах размер страниц может доходить до нескольких мегабайт. Загрузка больших файлов занимает много времени. Если на вашем сайте ожидается большой трафик, лучше всего загружать файлы HTML при запуске и сохранять их содержимое. После их загрузки вы можете настроить сервер так, чтобы он прослушивал запросы адреса.

Чтобы продемонстрировать этот метод, покажем, как можно сделать сервер более эффективным и масштабируемым.

### Эффективный вывод кода HTML

Вместо того чтобы загружать страницу HTML для каждого запроса, мы загрузим ее только один раз, в самом начале. Запрос будет возвращать данные, загруженные нами при запуске.

Откройте в терминале скрипт Node.js с помощью текстового редактора:

```
nano htmlFile.js

```

Copy

Добавим новую переменную, прежде чем создавать функцию `requestListener()`:

first-servers/htmlFile.js

```
...
let indexFile;

const requestListener = function (req, res) {
...

```

Copy

При запуске программы эта переменная будет хранить содержимое файла HTML.

Изменим функцию `requestListener()`. Теперь вместо загрузки файла она будет возвращать содержимое `indexFile`:

first-servers/htmlFile.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "text/html");
    res.writeHead(200);
    res.end(indexFile);
};
...

```

Copy

Далее мы изменим логику чтения файла с функции `requestListener()` на момент запуска нашего сервера. Внесите следующие изменения при создании сервера:

first-servers/htmlFile.js

```
...

const server = http.createServer(requestListener);

fs.readFile(__dirname + "/index.html")
    .then(contents => {
        indexFile = contents;
        server.listen(port, host, () => {
            console.log(`Server is running on http://${host}:${port}`);
        });
    })
    .catch(err => {
        console.error(`Could not read index.html file: ${err}`);
        process.exit(1);
    });

```

Copy

Сохраните файл и закройте `nano`, нажав `CTRL+X`.

Код, считывающий файл, похож на написанный нами при первой попытке. Однако при успешном чтении файла мы можем сохранить его содержимое в глобальной переменной `indexFile`. Мы запустим сервер с методом `listen()`. Главное — загрузить файл до запуска сервера. Так функция `requestListener()` гарантированно возвращает страницу HTML, поскольку переменная `indexFile` больше не пустая.

Блок обработки ошибок также изменился. Если файл не удается загрузить, мы записываем ошибку и выводим ее на консоль. Затем мы закрываем программу Node.js с помощью функции `exit()` без запуска сервера. Так мы видим, почему не удалось прочитать файл, и можем решить проблему и снова запустить сервер.

Мы создали разные веб-серверы, возвращающие пользователю разные типы данных. Пока что мы не использовали данные запросов для определения конкретного возвращаемого контента. Нам потребуется использовать данные запросов при настройке маршрутов или путей сервера Node.js, так что теперь мы посмотрим, как это работает.

## Шаг 4 — Управление маршрутами с использованием объекта HTTP Request

Большинство посещаемых нами сайтов и используемых нами API имеют несколько конечных точек, что позволяет получать доступ к разным ресурсам. Хорошим примером является система управления книгами, которая может использоваться в библиотеке. Ей нужно будет не только управлять данными книг, но и управлять данными авторов для составления каталогов и обеспечения удобства поиска.

Хотя данные книг и авторов связаны, они представляют собой разные объекты. В подобных случаях разработчики обычно программируют каждый объект для разных конечных точек, чтобы показать пользователю API, с какими данными он взаимодействует.

Создадим новый сервер для небольшой библиотеки, который будет возвращать два разных типа данных. Если пользователь откроет адрес сервера с `/books`, он получит список книг в формате JSON. Если пользователь откроет раздел `/authors`, он получит список с информацией об авторах в формате JSON.

До сих пор мы возвращали одинаковые ответы на каждый получаемый запрос. Рассмотрим небольшой пример.

Запустим заново наш пример с ответом JSON:

```
node json.js

```

Copy

Отправим на другом терминале запрос cURL, как мы делали ранее:

```
curl http://localhost:8000

```

Copy

Вы увидите следующее:

```
Output{"message": "This is a JSON response"}

```

Теперь попробуем другую команду curl:

```
curl http://localhost:8000/todos

```

Copy

После нажатия `Enter` вы увидите тот же самый результат:

```
Output{"message": "This is a JSON response"}

```

Мы не встраивали в функцию `requestListener()` никакую специальную логику дял обработки запроса, URL которого содержит `/todos`, и поэтому Node.js по умолчанию возвращает то же сообщение JSON.

Поскольку мы хотим создать небольшой сервер для управления библиотекой, мы разделим типы возвращаемых данных в зависимости от конечной точки пользователя.

Для начала закройте сервер, нажав `CTRL+C`.

Откройте файл `routes.js` в своем текстовом редакторе:

```
nano routes.js

```

Copy

Начнем с сохранения наших данных JSON в переменных перед функцией `requestListener()`:

first-servers/routes.js

```
...
const books = JSON.stringify([
    { title: "The Alchemist", author: "Paulo Coelho", year: 1988 },
    { title: "The Prophet", author: "Kahlil Gibran", year: 1923 }
]);

const authors = JSON.stringify([
    { name: "Paulo Coelho", countryOfBirth: "Brazil", yearOfBirth: 1947 },
    { name: "Kahlil Gibran", countryOfBirth: "Lebanon", yearOfBirth: 1883 }
]);
...

```

Copy

Переменная `books` — это строка, содержащая данные JSON для массива объектов книг. Каждая книга имеет заголовок или название, автора и год издания.

Переменная `authors` — это строка, содержащая данные JSON для массива объектов авторов. Каждый автор имеет имя, страну рождения и год рождения.

Теперь у нас имеются данные для ответов, и мы можем начать изменение функции `requestListener()` для использования желаемых маршрутов.

Вначале нужно убедиться, что все ответы нашего сервера будут иметь правильный заголовок `Content-Type`:

first-servers/routes.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
}
...

```

Copy

Далее нам нужно возвращать подходящие данные JSON в зависимости от URL, используемого пользователем. Создадим [выражение `switch`](https://www.digitalocean.com/community/tutorials/how-to-use-the-switch-statement-in-javascript) для URL запроса:

first-servers/routes.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
    switch (req.url) {}
}
...

```

Copy

Чтобы получить путь URL от объекта request, нам потребуется доступ к его свойству `url`. Теперь мы можем добавить в выражение `switch` варианты для возврата подходящего кода JSON.

Выражение `switch` в JavaScript позволяет определять, какой код будет выполняться в зависимости от значения объекта или выражения JavaScript (например, от результата математической операции). Если вы не знаете или забыли, как использовать такие выражения, воспользуйтесь нашим руководством [Использование выражения switch в JavaScript](https://www.digitalocean.com/community/tutorials/how-to-use-the-switch-statement-in-javascript).

Продолжим и добавим `вариант`, когда пользователь хочет получить список книг:

first-servers/routes.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
    switch (req.url) {
        case "/books":
            res.writeHead(200);
            res.end(books);
            break
    }
}
...

```

Copy

Мы устанавливаем код состояния `200`, указывая, что запрос обработан правильно, и возвращаем данные JSON, содержащие список книг. Добавим еще один `вариант` для авторов:

first-servers/routes.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
    switch (req.url) {
        case "/books":
            res.writeHead(200);
            res.end(books);
            break
        case "/authors":
            res.writeHead(200);
            res.end(authors);
            break
    }
}
...

```

Copy

Как и раньше, мы используем код состояния `200` для подтверждения правильного выполнения запроса. Теперь мы возвращаем данные JSON со списком авторов.

Если пользователь попробует использовать другой маршрут, нужно вывести сообщение об ошибке. Добавим для этой цели вариант по умолчанию:

routes.js

```
...
const requestListener = function (req, res) {
    res.setHeader("Content-Type", "application/json");
    switch (req.url) {
        case "/books":
            res.writeHead(200);
            res.end(books);
            break
        case "/authors":
            res.writeHead(200);
            res.end(authors);
            break
        default:
            res.writeHead(404);
            res.end(JSON.stringify({error:"Resource not found"}));
    }
}
...

```

Copy

Мы используем ключевое слово `default` в выражении `switch`, чтобы учесть все остальные сценарии, кроме описанных в предыдущих вариантах. Мы устанавливаем код состояния `404`, указывающий, что запрошенный URL не найден. Далее мы задаем объект JSON, содержащий сообщение об ошибке.

Протестируем поведение нашего сервера. Запустите на другом терминале команду, чтобы проверить, получим ли мы список книг:

```
curl http://localhost:8000/books

```

Copy

Нажмите `Enter`, чтобы получить следующий результат:

```
Output[{"title":"The Alchemist","author":"Paulo Coelho","year":1988},{"title":"The Prophet","author":"Kahlil Gibran","year":1923}]

```

Пока все хорошо. Попробуем то же самое для `/authors`. Введите в терминале следующую команду:

```
curl http://localhost:8000/authors

```

Copy

После выполнения команды вы увидите следующее:

```
Output[{"name":"Paulo Coelho","countryOfBirth":"Brazil","yearOfBirth":1947},{"name":"Kahlil Gibran","countryOfBirth":"Lebanon","yearOfBirth":1883}]

```

В заключение попробуем ввести ошибочный URL, чтобы функция `requestListener()` вывела сообщение об ошибке:

```
curl http://localhost:8000/notreal

```

Copy

При вводе этой команды будет выведено следующее сообщение:

```
Output{"error":"Resource not found"}

```

Закройте работающий сервер, нажав `CTRL+C`.

Мы создали несколько маршрутов для предоставления пользователям разных данных. Также мы добавили ответ по умолчанию, выводящий сообщение об ошибке HTTP, если пользователь вводит неправильный URL.

## Заключение

В этом обучающем руководстве мы создали несколько серверов HTTP Node.js. Вначале мы сформировали простой текстовый ответ. Затем мы перешли к возврату с сервера разных типов данных: JSON, CSV и HTML. Затем мы рассмотрели комбинирование загрузки файлов с ответами HTTP для вывода пользователю страниц HTML с сервера и создания API, использующего данные запроса пользователя для определения ответа.

Теперь вы готовы к созданию веб-серверов, которые смогут обрабатывать разнообразные запросы и ответы. Эти знания помогут вам создать сервер, возвращающий пользователю много разных страниц HTML для разных конечных точек. Также вы можете создавать собственные API.

Чтобы узнать больше о веб-серверах HTTP в Node.js, вы можете почитать [документацию Node.js](https://nodejs.org/docs/latest-v10.x/api/http.html) по модулю `http`. Если вы хотите продолжить изучение Node.js, возвращайтесь на страницу серии [Программирование в Node.js](https://www.digitalocean.com/community/tutorial_series/how-to-code-in-node-js).
